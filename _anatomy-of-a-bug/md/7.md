---
layout: page
title: "MongoBleed"
id: "007"
cve: "CVE-2025-14847"
target: "MongoDB"
severity: "8.7"
pdf_file: "AOAB7.pdf"
sidebar_link: false
date_finding: "2025-12-25"
date_upload: "2025-12-31"
status: "DECLASSIFIED"
tags: [MongoDB, Zlib, Infosec, HeapGrooming, ZeroDay]
credits: "Joe DeSimone, MongoDB Security Team"
summary: "MongoBleed (CVE-2025-14847): A pre-auth heap bleed in MongoDB's Zlib compressor. Results in leakage of uninitialized memory."
---

## 1. The Patient

**Target:** MongoDB Wire Protocol (Port 27017)  
**Component:** `message_compressor_zlib.cpp`  
**Vector:** Pre-authentication Remote Network Access

MongoDB is the nervous system of modern infrastructure, handling unstructured data for millions of applications. Its communication layer, the **Wire Protocol**, sits directly on top of TCP/IP. While legacy implementations used `OP_QUERY`, modern versions utilize `OP_MSG` wrapped in a generic BSON envelope.

The vulnerability resides in the **Compression Negotiation** layer. Introduced in 2012 to optimize bandwidth, the `OP_COMPRESSED` opcode allows clients to send compressed payloads. While Snappy and Zstd implementations are safe, the **Zlib** implementation (ID 2)—often the default in package manager distributions—contained a fatal logic error in how it handled memory allocation.

> **The Context:** This Zero-Day was disclosed on December 25, 2025. Attackers leveraged the "Holiday Freeze" fallacy, knowing SOC staffing would be minimal, to harvest credentials before defenders returned.

## 2. The Diagnosis

**Root Cause:** Information Disclosure via Heap Memory Bleed.

The flaw is a classic **Trust-but-Verify failure** in C++ memory management. When a client sends a compressed message, the header includes an `uncompressedSize` field. This field is intended to be a hint for the server to pre-allocate a buffer of the correct size.

The failure occurs in the return logic of the decompression wrapper:

1.  **The Claim:** The attacker sends a header claiming the uncompressed payload is **1MB**.
2.  **The Allocation:** The server trusts this claim and allocates 1MB from the heap (`tcmalloc`). Crucially, this memory is "dirty"—it contains leftover data from previous operations (e.g., authentication hashes, API keys).
3.  **The Reality:** The attacker only sends a single byte of compressed data (e.g., the letter 'A').
4.  **The Bug:** The function returns `output.length()` (the *allocated capacity* of 1MB) instead of the actual `bytes_written` (1 Byte).

The server then treats the entire 1MB buffer as valid response data and reflects it back to the client. The attacker receives their single 'A', followed by **1,048,575 bytes of uninitialized server memory**.

## 3. The Kill-Chain

### Phase 1: Reconnaissance & Deviation
Standard MongoDB drivers initiate a connection with a polite `hello` handshake. Exploit scripts are rude; they skip the handshake entirely and immediately transmit a malicious `OP_COMPRESSED` packet. This works because the wire protocol processes compression before authentication.

### Phase 2: Heap Grooming
To maximize the value of the leak, the attacker must ensure the "dirty" memory contains sensitive data.
* **Technique:** The attacker opens **50 concurrent connections**.
* **Execution:** 49 connections perform legitimate login attempts or queries, forcing the memory allocator to fill the heap with `SCRAM-SHA-256` hashes, session tokens, and BSON documents.
* **Trigger:** The 50th connection triggers the exploit. The allocator recycles the recently freed pages—now full of fresh credentials—to satisfy the exploit's 1MB buffer request.

### Phase 3: The Bleed
The attacker sends the payload:
* Header: `uncompressedSize: 1048576`
* Body: `zlib("A")`

The server responds with the massive buffer. The attacker captures the stream and parses it for high-value patterns:
* `SCRAM-SHA-256` (Authentication hashes)
* `"user":` (PII / Usernames)
* `AWS_ACCESS_KEY` (Infrastructure compromise)

> **Impact:** While primarily an Information Disclosure bug, leaked memory pointers can defeat **ASLR** (Address Space Layout Randomization), and leaked session tokens allow for immediate **Auth Bypass**, paving the way for full Remote Code Execution (RCE).

## 4. The Fix

The remediation requires enforcing strict accounting of written bytes. The application must never trust the client's declared size for the final response.

**Vulnerable Logic:**
```cpp
Status swM = zlib::inflate(input, &output);
// FATAL: Returns the allocated capacity, not the actual data size.
return output.length(); 

```

**Patched Logic:**

```cpp
size_t bytesWritten;
Status swM = zlib::inflate(input, &output, &bytesWritten);

// SECURITY FIX: Resize the buffer to match ONLY the valid data.
output.resize(bytesWritten);
return output.length(); 

```

### Developer Takeaway

**Memory Safety is not solved.** The internet runs on C++, and functions like `output.length()` can be deceptive. The developers assumed it returned the "used" size, but it returned the "reserved" size. This ambiguity caused a critical global vulnerability.

**Immediate Action:**

1. **Patch:** Upgrade to MongoDB 8.0.17+, 7.0.28+, or 6.0.27+.
2. **Mitigate:** If patching is impossible, edit `mongod.conf` to remove `zlib` from `net.compression.compressors`.
3. **Defense:** Ensure port 27017 is never exposed to the public internet. Internal trust is a myth.
