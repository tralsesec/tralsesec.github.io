---
layout: page
title: "FortiWeb Edge Collapse"
id: "005"
cve: "CVE-2025-64446, CVE-2025-58034"
target: "Fortinet FortiWeb"
severity: "9.8"
pdf_file: "AOAB5.pdf"
sidebar_link: false
date_finding: "2025-11-14"
date_upload: "2025-12-22"
status: "DECLASSIFIED"
tags: [Fortinet, FortiWeb, Web, WAF, AuthBypass, CommandInjection, CGI, PathTraversal, RCE, ZeroDay]
credits: "watchTowr, Fortinet PSIRT"
summary: "FortiWeb Edge Collapse (CVE-2025-64446, CVE-2025-58034): A critical CVSS 9.8 dual-vulnerability chain in the Fortinet FortiWeb WAF."
---

## 1. The Patient

**Target:** Fortinet FortiWeb 
**Component:** `fwbcgi` (Administrative CGI Binary)
**Vector:** HTTP POST (Remote)

FortiWeb is positioned as the shield for critical assetsâ€”a Web Application Firewall (WAF) designed to filter malicious traffic. However, internally, it relies on a legacy architecture: **Apache** coupled with **CGI binaries**, a model dating back decades.

The security model relied on two fatal assumptions:
1.  Requests reaching the internal CGI handlers are trusted.
2.  Specific headers (like `CGIINFO`) originate only from internal IPC components.

These assumptions crumbled when exposed to the public internet, leading to a **CVSS 9.8** collapse.

> **The Context:** This is a dual-failure chain. **CVE-2025-64446** allows an attacker to bypass authentication entirely by forging internal headers. **CVE-2025-58034** then leverages that fake identity to inject shell commands into the policy management engine.

## 2. The Diagnosis

**Root Cause:** Full Authentication Collapse via Trust Boundary Violation.

The vulnerability stems from **Path Resolution** issues in Apache and **Implicit Trust** in the `fwbcgi` binary.

### Part 1: The Authentication Mirage (CVE-2025-64446)
Legitimate API endpoints live under `/api/v2.0/cmdb/`. Apache processes the URL path before enforcing logical boundaries. By using path traversal (`../`), an attacker can escape the API logic and invoke `fwbcgi` directly.

Once inside, `fwbcgi` calls `cgi_auth()`. Instead of checking a database or a cryptographic session token, it looks for a header named `CGIINFO`.
* **The Logic:** If `CGIINFO` exists, the system Base64-decodes it, parses the JSON, and "hydrates" the user session based on the data inside.
* **The Failure:** There is no cryptographic signature. If the attacker sends this header, they *become* the Admin.

### Part 2: The Command Injection (CVE-2025-58034)
Once authenticated as a fake Admin, the attacker targets the `policy_scripting_post_handler`. This handler is responsible for creating automation scripts. It constructs a shell command to invoke an underlying OS utility:
`/usr/local/bin/run_script --name <user_input>`

The handler builds this command using **string concatenation** rather than argument vectors. It inserts user-controlled JSON fields (like `name` or `script`) verbatim.

## 3. The Kill-Chain

### Phase 1: Path Traversal
The attacker bypasses the application layer routing by sending a request that traverses out of the API directory:
<code style="word-break: break-all; white-space: normal;">POST /api/v2.0/cmdb/system/admin/../../../../../cgi-bin/fwbcgi</code> 

### Phase 2: Identity Forgery
The attacker injects the malicious `CGIINFO` header to forge a Super-Admin identity:
```json
{
  "username": "admin",
  "profname": "super_admin",
  "vdom": "root",
  "loginname": "admin"
}

```

`fwbcgi` trusts this input blindly and grants full privileges.

### Phase 3: OS Command Injection

With Admin access, the attacker sends a payload to the scripting handler:
`name = "test; /bin/sh -c 'id'"`

The server executes:

1. `/usr/local/bin/run_script --name test` (Legitimate)
2. `/bin/sh -c 'id'` (Malicious)

> **Impact:** The attacker gains **Remote Code Execution (RCE) as Root** (UID 0). Because the appliance has no privilege separation, no chroot, and no seccomp filters, the compromise is total.

### Phase 4: Post-Exploitation

Forensic analysis indicates this vector was used as a beachhead to attack downstream infrastructure, including the **Cisco AsyncOS** appliances detailed in **AOAB #6**.

## 4. The Fix

The remediation requires enforcing strict boundaries at the web server level and removing shell invocation from the code.

**Vulnerable Logic (C++):**

```cpp
// FATAL: String concatenation allows shell metacharacters (; | &)
std::string cmd = "/usr/local/bin/run_script --name " + user_input;
system(cmd.c_str());

```

**Patched Logic (C++):**

```cpp
// SECURITY FIX: Use execve/fork with an argument array.
// The shell is never invoked, so '; id' is treated as a filename, not a command.
char *args[] = {"/usr/local/bin/run_script", "--name", user_input.c_str(), NULL};
execve(args[0], args, env);

```

### Developer Takeaway

**Trust is not a boundary.** Headers are user input, not a trust signal. Assuming that "only internal components set this header" is a fatal flaw in any internet-facing device. Furthermore, **CGI is not sandboxed**. It executes with ambient privilege. Systems must be designed to assume hostile traffic by default, verifying every claim of identity cryptographically.

**Immediate Action:**

1. **Patch:** Upgrade to FortiWeb 8.0.2+.
2. **Mitigate:** Restrict access to the management interface.
3. **Sanitize:** Ensure upstream load balancers block requests containing `/cgi-bin/` in the URL path.
