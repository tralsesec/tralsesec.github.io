---
layout: page
title: "Lazarus 0day (AppLocker LPE)"
id: "002"
cve: "CVE-2024-21338"
target: "Windows AppLocker"
severity: "7.8"
pdf_file: "AOAB2.pdf"
sidebar_link: false
date_finding: "2024-02-13"
date_upload: "2025-12-15"
status: "DECLASSIFIED"
tags: [Windows, Lazarus, ExploitDev, LPE, Kernel, Rootkit, CVE-2024-21338]
credits: "Jan Vojtěšek (Avast), Lazarus Group"
summary: "Lazarus 0day (AppLocker LPE): A critical CVSS 7.8 Local Privilege Escalation (LPE) vulnerability in the Windows AppLocker driver (appid.sys)."
---

## 1. The Patient

[cite_start]**Target:** Windows AppLocker (`appid.sys`)  [cite: 6, 7]
[cite_start]**Component:** `AppHashComputeImageHashInternal` (Kernel Driver) [cite: 73]
[cite_start]**Vector:** Local Logic Flaw (Input Processing) [cite: 11]

The target is **AppLocker** (`appid.sys`), a native Windows kernel driver responsible for application control. [cite_start]Unlike the typical "Loud" BYOVD (Bring Your Own Vulnerable Driver) attacks where adversaries drop old drivers to hack the kernel, the **Lazarus Group** chose the "Silent" path[cite: 26, 27]. [cite_start]They exploited a driver that is already running by default in Windows, achieving a true "Living off the Land" exploit with zero load events to alert defenders[cite: 27, 28].

> [cite_start]**The Context:** This Zero-Day was weaponized by the Lazarus Group to deploy a Rootkit[cite: 14]. [cite_start]Their goal was **Direct Kernel Object Manipulation (DKOM)** to unlink security callbacks, effectively blinding EDR/AV solutions like CrowdStrike and Windows Defender from Ring 0[cite: 15, 17, 18, 29].

## 2. The Diagnosis

**Root Cause:** Blind Trust in User Input leading to Arbitrary Indirect Call.

[cite_start]The vulnerability is a classic logic flaw in how the driver processes input buffers[cite: 11, 31].
1.  [cite_start]**The Flaw:** The driver reads a value directly from the user-supplied input buffer and treats it as a function pointer[cite: 34].
2.  [cite_start]**The Danger:** It performs an **indirect call** to this address without verifying the caller's origin or the pointer's validity[cite: 35].
3.  [cite_start]**The Implication:** `appid.sys` implicitly trusts that the pointer is safe, failing to check if the request originated from an untrusted User-Mode source[cite: 36].

## 3. The Kill-Chain

### Phase 1: Access Control Dance (The Setup)
Before triggering the bug, the attacker must talk to the driver. [cite_start]The device object `\Device\AppID` has an Access Control List (ACL) that denies write access to standard Administrators (`STATUS_ACCESS_DENIED`)[cite: 46, 47]. [cite_start]However, the account **LOCAL SERVICE** has explicit Write permission[cite: 48].

[cite_start]The attacker performs a token manipulation dance[cite: 103]:
1.  **Upgrade (Admin → SYSTEM):** Use `SeDebugPrivilege` to steal the token from `winlogon.exe` (SYSTEM). [cite_start]This grants `SeAssignPrimaryTokenPrivilege`[cite: 56, 61].
2.  [cite_start]**Downgrade (SYSTEM → LOCAL SERVICE):** Use the SYSTEM token to duplicate the `LOCAL SERVICE` token from a running `svchost.exe`[cite: 65].
3.  **Access:** Spawn a new process with the `LOCAL SERVICE` token. [cite_start]This process can now successfully open a handle to `\Device\AppID`[cite: 67, 68].

### Phase 2: The Trigger & The Gadget
[cite_start]The attacker sends IOCTL `0x22A018` to the open handle[cite: 71]. [cite_start]The driver passes the input to `AppHashComputeImageHashInternal`, which executes the unchecked function pointer[cite: 72, 73].

[cite_start]**The Obstacle:** Modern Windows protections **kCFG** (Kernel Control Flow Guard) and **SMEP** (Supervisor Mode Execution Prevention) prevent simply jumping to shellcode[cite: 75, 78].
[cite_start]**The Solution:** The attacker uses a valid "Gadget" that is allowed by kCFG: `ExpProfileDelete()`[cite: 82, 83].
* [cite_start]**Mechanism:** Internally, this function calls `ObfDereferenceObject` to decrement a reference count[cite: 84].
* [cite_start]**Abuse:** The attacker weaponizes this to perform an arbitrary decrement: `*Address = *Address - 1`[cite: 85].

### Phase 3: The Corruption (Previous Mode)
[cite_start]The target of this decrement is the **Previous Mode** field in the current thread's `_KTHREAD` structure[cite: 87, 96].
* **User Mode (1):** Untrusted. [cite_start]The kernel validates every pointer[cite: 90].
* **Kernel Mode (0):** Trusted. [cite_start]The kernel assumes the caller is safe[cite: 91].

[cite_start]**The Math:** Current Value (`0x01`) minus Gadget Action (`1`) equals **`0x00` (Kernel Mode)**[cite: 98].
Once this byte flips to 0, the kernel treats the attacker's thread as trusted (Ring 0). [cite_start]System calls now bypass security constraints, granting unrestricted Read/Write access to the entire system memory[cite: 99, 100].

## 4. The Fix

The remediation was simple: Microsoft added a check to ensure the IOCTL is not called from User Mode.

**Vulnerable Logic:**
[cite_start]The driver accepted the IOCTL and processed the pointer regardless of the caller's privileges[cite: 119].

**Patched Logic:**
```cpp
[cite_start]// Pseudo-code based on binary diffing [cite: 126]

NTSTATUS AipSmartHashImageFile(...) {
    [cite_start]// THE FIX: Verify caller mode [cite: 129]
    if (ExGetPreviousMode() != KernelMode) {
        [cite_start]return STATUS_ACCESS_DENIED; [cite: 130]
    }
    
    // "Vulnerable" logic continues only if the caller is already Kernel...
    [cite_start]AppHashComputeImageHashInternal(...); [cite: 131]
}

```

### Developer Takeaway

**Implicit Trust is Deadly.** The driver assumed that because it was an internal component, the code execution flow was safe. It wasn't.

* 
**Validate Context:** When exposing sensitive functions via IOCTLs, always verify the execution context (`ExGetPreviousMode`).


* 
**Gadgets are Everywhere:** Even with robust protections like kCFG, legitimate code (like `ExpProfileDelete`) can be weaponized if a logic flaw allows you to control its inputs.
